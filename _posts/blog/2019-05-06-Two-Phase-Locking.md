---
layout: post
title: 两阶段加锁协议
categories: [Distributed]
description: Two-Phase Locking -- 2PL
keywords: Two-Phase Locking
---

两阶段加锁协议

---

#### 概念

并发控制: 所谓并发控制，是指多用户共享的系统中，许多用户可能同时对同一数据进行操作。

调度: 指的是事务的执行次序。

串行调度: 多个事务依次串行执行，且只有当一个事务的所有操作都执行完后才执行另一个事务的所有操作。
只要是串行调度，执行的结果都是正确的。

并行调度: 利用分时的方法同时处理多个事务。但是并行调度的调度结果可能是错误的，
可能产生不一致的状态，包括有: 丢失修改，不可重复读和读脏数据。

可串行化: 调度是一个或多个事务的重要操作按时间排序的一个序列。
如果一个调度的动作首先是一个事务的所有动作，然后是另一个事务的所有动作，以此类推，而没有动作的混合，那么我们说这一调度是串行的。

其实比较明显的是虽然串行调度能够保证调度结果的正确性，
但是却限制了系统并行性的发挥，不能有效利用资源，
但是并行调度的调度结果又可能出现错误，
而且可能不具有串行，正是因为这样，有一个具有串行调度效果的并行调度方法，
而两段锁协议就是保证并行事务可串化的方法。

如果一并行调度的结果等价于某一串行调度的结果，那么这个并行调度成为可串行化的

#### 规则

两段锁协议规定所有的事务应遵守的规则：

> * ① 在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁。
> * ② 在释放一个封锁之后，事务不再申请和获得其它任何封锁。

#### 阶段

两段锁协议：是指所有的事务必须分两个阶段对数据项加锁和解锁。

事务的执行分为两个阶段: 
> * 第一阶段是获得封锁的阶段，称为扩展阶段。
> * 第二阶段是释放封锁的阶段，称为收缩阶段。

第一阶段是事务可以获得任何数据项上的任何类型的锁，但是不能释放。

其实也就是该阶段可以进入加锁操作，在对任何数据进行读操作之前要申请获得S锁，
在进行写操作之前要申请并获得X锁，加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。
就是加锁后就不能解锁了。

第二阶段是释放封锁，事务可以释放任何数据项上的任何类型的锁，但不能申请。

当事务释放一个封锁后，事务进入封锁阶段，在该阶段只能进行解锁而不能再进行加锁操作。

定理: 若所有事务均遵守两段锁协议，则这些事务的所有交叉调度都是可串行化的。

![](/images/blog/2019-05-06-5.png){:height="80%" width="80%"}

#### 死锁

遵循两段锁协议的事务有可能发生死锁。

两个事务都坚持请求加锁对方已经占有的数据，导致死锁。

为此，又有了一次封锁法。一次封锁法要求事务必须一次性将所有要使用的数据全部加锁，否则就不能继续执行。

因此，一次封锁法遵守两段锁协议，但两段锁并不要求事务必须一次性将所有要使用的数据全部加锁，
这一点与一次性封锁不同，这就是遵守两段锁协议仍可能发生死锁的原因所在。

#### 总结

串行调度效果的并行调度方法。

简单的理解就是两段锁，就是分为两个阶段
第一阶段 只能去申请锁
第二阶段 只能去释放锁

---
参考链接
* [zookeeper学习之一：两段锁协议](https://www.jianshu.com/p/5c78f5c4d57b)
* [两段锁协议](https://blog.csdn.net/sinat_36841379/article/details/75107985)
* [数据库管理（事务、ACID、并发、封锁、可串行化、隔离）（转）](https://www.cnblogs.com/3013218061shang/p/5573476.html)